"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unload = exports.load = exports.methods = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const xlsx = __importStar(require("xlsx"));
const excelConverter = {
    cleanDirectory(dir, ext) {
        if (!fs.existsSync(dir))
            return;
        const files = fs.readdirSync(dir);
        files.forEach((file) => {
            if (file.endsWith(ext)) {
                const filePath = path.join(dir, file);
                fs.unlinkSync(filePath); // 删除文件
                console.log(`[Clean] Deleted: ${filePath}`);
            }
        });
    },
    validateType(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return;
        }
        if (type.endsWith("[]")) {
            if (typeof value !== "string") {
                throw new Error(`Expected array (string) but got ${typeof value}`);
            }
            return;
        }
        switch (type) {
            case "int":
            case "number":
                if (isNaN(Number(value))) {
                    throw new Error(`Expected number but got "${value}"`);
                }
                break;
            case "boolean":
                if (typeof value === "string") {
                    const lower = value.toLowerCase();
                    if (lower !== "true" && lower !== "false") {
                        throw new Error(`Expected boolean (true/false) but got "${value}"`);
                    }
                }
                else if (typeof value !== "boolean") {
                    throw new Error(`Expected boolean but got ${typeof value}`);
                }
                break;
            case "json":
                try {
                    const parsed = typeof value === "string" ? JSON.parse(value) : value;
                    if (typeof parsed !== "object" || parsed === null) {
                        throw new Error(`Expected JSON object but got ${typeof parsed}`);
                    }
                }
                catch (e) {
                    throw new Error(`Invalid JSON: ${value}`);
                }
                break;
            case "date":
                const date = new Date(value);
                if (isNaN(date.getTime())) {
                    throw new Error(`Invalid date format: "${value}"`);
                }
                break;
            // Add more type validations as needed
        }
    },
    parseValue(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return null;
        }
        // Validate type first
        this.validateType(value, type, context);
        // Handle array types
        if (type.endsWith("[]")) {
            const elementType = type.replace("[]", "");
            const trimmedValue = value.trim();
            if (trimmedValue === "[]" || trimmedValue === "")
                return [];
            try {
                // Try to parse as JSON array
                const parsed = JSON.parse(trimmedValue);
                if (Array.isArray(parsed)) {
                    return parsed.map((item, index) => this.parseValue(item, elementType, {
                        row: context.row,
                        field: `${context.field}[${index}]`,
                    }));
                }
                return [
                    this.parseValue(parsed, elementType, {
                        row: context.row,
                        field: `${context.field}[0]`,
                    }),
                ];
            }
            catch (e) {
                // Fallback to comma-separated values
                const items = trimmedValue.split(",").map((s) => s.trim());
                return items.map((item, index) => this.parseValue(item, elementType, {
                    row: context.row,
                    field: `${context.field}[${index}]`,
                }));
            }
        }
        //
        // Handle basic types
        switch (type) {
            case "int":
            case "number":
                return Number(value);
            case "string":
                return String(value);
            case "boolean":
                if (typeof value === "string") {
                    return value.toLowerCase() === "true";
                }
                return Boolean(value);
            case "json":
                return typeof value === "string" ? JSON.parse(value) : value;
            case "date":
                return new Date(value).toISOString();
            default:
                return value;
        }
    },
    convertSheetToTypedJson(sheet, filename) {
        const excelData = xlsx.utils.sheet_to_json(sheet, { header: 1 });
        if (excelData.length < 3)
            return [];
        const typeDefs = excelData[0]; // 第一行：数据类型
        const fieldNames = excelData[1]; // 第二行：字段名
        const result = [];
        const errors = [];
        // 从第三行开始解析数据
        for (let i = 2; i < excelData.length; i++) {
            const row = excelData[i];
            const obj = {};
            for (let j = 0; j < fieldNames.length; j++) {
                const fieldName = fieldNames[j];
                if (!fieldName)
                    continue;
                const fieldType = typeDefs[j] || "string";
                const rawValue = row[j];
                try {
                    obj[fieldName] = this.parseValue(rawValue, fieldType, {
                        row: i + 1,
                        field: fieldName,
                    });
                }
                catch (error) {
                    errors.push(`[${filename}] 行 ${i + 1}, 列 "${fieldName}": ${error.message}\n` +
                        `类型: ${fieldType}, 值: ${JSON.stringify(rawValue)}`);
                }
            }
            if (Object.keys(obj).length > 0) {
                result.push(obj);
            }
        }
        if (errors.length > 0) {
            throw new Error(`发现 ${errors.length} 个类型错误:\n${errors.join("\n\n")}`);
        }
        return result;
    },
    convertExcelToJson() {
        try {
            console.log("[ExcelConverter] Starting conversion");
            // 获取项目根目录的上一级目录
            const projectParentDir = path.dirname(Editor.Project.path);
            // 设置Excel目录为上一级目录的res/data
            const excelDir = path.join(projectParentDir, "res", "data");
            const outputDir = path.join(Editor.Project.path, "assets", "resources", "config");
            if (!fs.existsSync(excelDir)) {
                fs.mkdirSync(excelDir, { recursive: true });
                Editor.Dialog.info(`Created excel directory: ${excelDir}`);
                return;
            }
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            this.cleanDirectory(outputDir, ".json");
            // 更健壮的临时文件过滤方案
            const files = fs.readdirSync(excelDir).filter((file) => {
                const ext = path.extname(file).toLowerCase();
                const isXlsx = ext === ".xlsx";
                const isTempFile = file.startsWith("~$") || file.startsWith("~"); // 匹配两种临时文件格式
                // 只保留.xlsx且不是临时文件
                return isXlsx && !isTempFile;
            });
            if (files.length === 0) {
                Editor.Dialog.info("[ExcelConverter] No .xlsx files found in: " + excelDir);
                return;
            }
            let successCount = 0;
            const failedFiles = [];
            const allErrors = [];
            for (const file of files) {
                try {
                    const excelPath = path.join(excelDir, file);
                    const jsonName = path.basename(file, ".xlsx") + ".json";
                    const jsonPath = path.join(outputDir, jsonName);
                    const workbook = xlsx.readFile(excelPath);
                    const sheetNames = workbook.SheetNames;
                    if (sheetNames.length === 0) {
                        throw new Error("No worksheets found");
                    }
                    const data = this.convertSheetToTypedJson(workbook.Sheets[sheetNames[0]], file);
                    fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2));
                    successCount++;
                    console.log(`[ExcelConverter] Success: ${file} -> ${jsonName}`);
                }
                catch (error) {
                    failedFiles.push(file);
                    allErrors.push(`${file}: ${error.message}`);
                    console.error(`[ExcelConverter] Failed: ${file}`, error);
                }
            }
            let report = `[ExcelConverter] 转换完成!\n\n成功: ${successCount}\n失败: ${failedFiles.length}`;
            if (allErrors.length > 0) {
                report += `\n\n错误详情:\n${allErrors.join("\n\n")}`;
            }
            if (failedFiles.length > 0) {
                Editor.Dialog.error("[ExcelConverter] 转换出错" + report);
            }
            else {
                Editor.Dialog.info("[ExcelConverter] 转换完成" + report);
            }
        }
        catch (error) {
            console.error("[ExcelConverter] Global error:", error);
            Editor.Dialog.error("[ExcelConverter] 错误", error.message);
        }
    },
};
exports.methods = {
    execute: async function () {
        console.log("[ExcelConverter] Executing...");
        excelConverter.convertExcelToJson();
        return true;
    },
};
function load() { }
exports.load = load;
function unload() { }
exports.unload = unload;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NvdXJjZS9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYix1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLDJDQUE2QjtBQWtCN0IsTUFBTSxjQUFjLEdBQW1CO0lBQ25DLGNBQWMsQ0FBQyxHQUFXLEVBQUUsR0FBVztRQUNuQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7WUFBRSxPQUFPO1FBRWhDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ25CLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ3RDLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPO2dCQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixRQUFRLEVBQUUsQ0FBQyxDQUFDO2FBQy9DO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsWUFBWSxDQUNSLEtBQVUsRUFDVixJQUFZLEVBQ1osT0FBdUM7UUFFdkMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUUsRUFBRTtZQUN2RCxPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQ1gsbUNBQW1DLE9BQU8sS0FBSyxF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LEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUM3RDtJQUNMLENBQUM7Q0FDSixDQUFDO0FBRVcsUUFBQSxPQUFPLEdBQUc7SUFDbkIsT0FBTyxFQUFFLEtBQUs7UUFDVixPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7UUFDN0MsY0FBYyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDcEMsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztDQUNKLENBQUM7QUFFRixTQUFnQixJQUFJLEtBQUksQ0FBQztBQUF6QixvQkFBeUI7QUFDekIsU0FBZ0IsTUFBTSxLQUFJLENBQUM7QUFBM0Isd0JBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIHhsc3ggZnJvbSBcInhsc3hcIjtcblxuaW50ZXJmYWNlIEV4Y2VsQ29udmVydGVyIHtcbiAgICBwYXJzZVZhbHVlKFxuICAgICAgICB2YWx1ZTogYW55LFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNvbnRleHQ6IHsgcm93OiBudW1iZXI7IGZpZWxkOiBzdHJpbmcgfVxuICAgICk6IGFueTtcbiAgICBjb252ZXJ0U2hlZXRUb1R5cGVkSnNvbihzaGVldDogYW55LCBmaWxlbmFtZTogc3RyaW5nKTogYW55W107XG4gICAgY29udmVydEV4Y2VsVG9Kc29uKCk6IHZvaWQ7XG4gICAgY2xlYW5EaXJlY3RvcnkoZGlyOiBzdHJpbmcsIGV4dDogc3RyaW5nKTogdm9pZDtcbiAgICB2YWxpZGF0ZVR5cGUoXG4gICAgICAgIHZhbHVlOiBhbnksXG4gICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgY29udGV4dDogeyByb3c6IG51bWJlcjsgZmllbGQ6IHN0cmluZyB9XG4gICAgKTogdm9pZDtcbn1cblxuY29uc3QgZXhjZWxDb252ZXJ0ZXI6IEV4Y2VsQ29udmVydGVyID0ge1xuICAgIGNsZWFuRGlyZWN0b3J5KGRpcjogc3RyaW5nLCBleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyKTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGUuZW5kc1dpdGgoZXh0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGRpciwgZmlsZSk7XG4gICAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhmaWxlUGF0aCk7IC8vIOWIoOmZpOaWh+S7tlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQ2xlYW5dIERlbGV0ZWQ6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVR5cGUoXG4gICAgICAgIHZhbHVlOiBhbnksXG4gICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgY29udGV4dDogeyByb3c6IG51bWJlcjsgZmllbGQ6IHN0cmluZyB9XG4gICAgKTogdm9pZCB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5lbmRzV2l0aChcIltdXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYXJyYXkgKHN0cmluZykgYnV0IGdvdCAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImludFwiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlmIChpc05hTihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG51bWJlciBidXQgZ290IFwiJHt2YWx1ZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb3dlciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlciAhPT0gXCJ0cnVlXCIgJiYgbG93ZXIgIT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBib29sZWFuICh0cnVlL2ZhbHNlKSBidXQgZ290IFwiJHt2YWx1ZX1cImBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIGJ1dCBnb3QgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgIT09IFwib2JqZWN0XCIgfHwgcGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIEpTT04gb2JqZWN0IGJ1dCBnb3QgJHt0eXBlb2YgcGFyc2VkfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIGZvcm1hdDogXCIke3ZhbHVlfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQWRkIG1vcmUgdHlwZSB2YWxpZGF0aW9ucyBhcyBuZWVkZWRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZVZhbHVlKFxuICAgICAgICB2YWx1ZTogYW55LFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNvbnRleHQ6IHsgcm93OiBudW1iZXI7IGZpZWxkOiBzdHJpbmcgfVxuICAgICk6IGFueSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHR5cGUgZmlyc3RcbiAgICAgICAgdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIHR5cGUsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBhcnJheSB0eXBlc1xuICAgICAgICBpZiAodHlwZS5lbmRzV2l0aChcIltdXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IHR5cGUucmVwbGFjZShcIltdXCIsIFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFZhbHVlID0gdmFsdWUudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAodHJpbW1lZFZhbHVlID09PSBcIltdXCIgfHwgdHJpbW1lZFZhbHVlID09PSBcIlwiKSByZXR1cm4gW107XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIEpTT04gYXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHRyaW1tZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkLm1hcCgoaXRlbSwgaW5kZXgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVmFsdWUoaXRlbSwgZWxlbWVudFR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IGNvbnRleHQucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBgJHtjb250ZXh0LmZpZWxkfVske2luZGV4fV1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVZhbHVlKHBhcnNlZCwgZWxlbWVudFR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogY29udGV4dC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogYCR7Y29udGV4dC5maWVsZH1bMF1gLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRyaW1tZWRWYWx1ZS5zcGxpdChcIixcIikubWFwKChzOiBhbnkpID0+IHMudHJpbSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtOiBhbnksIGluZGV4OiBhbnkpID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VWYWx1ZShpdGVtLCBlbGVtZW50VHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBjb250ZXh0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBgJHtjb250ZXh0LmZpZWxkfVske2luZGV4fV1gLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBIYW5kbGUgYmFzaWMgdHlwZXNcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50XCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb252ZXJ0U2hlZXRUb1R5cGVkSnNvbihzaGVldDogYW55LCBmaWxlbmFtZTogc3RyaW5nKTogYW55W10ge1xuICAgICAgICBjb25zdCBleGNlbERhdGEgPSB4bHN4LnV0aWxzLnNoZWV0X3RvX2pzb24oc2hlZXQsIHsgaGVhZGVyOiAxIH0pO1xuXG4gICAgICAgIGlmIChleGNlbERhdGEubGVuZ3RoIDwgMykgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IHR5cGVEZWZzOiBhbnkgPSBleGNlbERhdGFbMF07IC8vIOesrOS4gOihjO+8muaVsOaNruexu+Wei1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzOiBhbnkgPSBleGNlbERhdGFbMV07IC8vIOesrOS6jOihjO+8muWtl+auteWQjVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIC8vIOS7juesrOS4ieihjOW8gOWni+ino+aekOaVsOaNrlxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGV4Y2VsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSBleGNlbERhdGFbaV07XG4gICAgICAgICAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBmaWVsZE5hbWVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGROYW1lKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHR5cGVEZWZzW2pdIHx8IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSByb3dbal07XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbZmllbGROYW1lXSA9IHRoaXMucGFyc2VWYWx1ZShyYXdWYWx1ZSwgZmllbGRUeXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IGkgKyAxLCAvLyBFeGNlbOihjOWPt+S7jjHlvIDlp4tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBgWyR7ZmlsZW5hbWV9XSDooYwgJHtpICsgMX0sIOWIlyBcIiR7ZmllbGROYW1lfVwiOiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBg57G75Z6LOiAke2ZpZWxkVHlwZX0sIOWAvDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYOWPkeeOsCAke2Vycm9ycy5sZW5ndGh9IOS4quexu+Wei+mUmeivrzpcXG4ke2Vycm9ycy5qb2luKFwiXFxuXFxuXCIpfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjb252ZXJ0RXhjZWxUb0pzb24oKTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltFeGNlbENvbnZlcnRlcl0gU3RhcnRpbmcgY29udmVyc2lvblwiKTtcblxuICAgICAgICAgICAgLy8g6I635Y+W6aG555uu5qC555uu5b2V55qE5LiK5LiA57qn55uu5b2VXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0UGFyZW50RGlyID0gcGF0aC5kaXJuYW1lKEVkaXRvci5Qcm9qZWN0LnBhdGgpO1xuICAgICAgICAgICAgLy8g6K6+572uRXhjZWznm67lvZXkuLrkuIrkuIDnuqfnm67lvZXnmoRyZXMvZGF0YVxuICAgICAgICAgICAgY29uc3QgZXhjZWxEaXIgPSBwYXRoLmpvaW4ocHJvamVjdFBhcmVudERpciwgXCJyZXNcIiwgXCJkYXRhXCIpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0RGlyID0gcGF0aC5qb2luKFxuICAgICAgICAgICAgICAgIEVkaXRvci5Qcm9qZWN0LnBhdGgsXG4gICAgICAgICAgICAgICAgXCJhc3NldHNcIixcbiAgICAgICAgICAgICAgICBcInJlc291cmNlc1wiLFxuICAgICAgICAgICAgICAgIFwiY29uZmlnXCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhleGNlbERpcikpIHtcbiAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMoZXhjZWxEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIEVkaXRvci5EaWFsb2cuaW5mbyhgQ3JlYXRlZCBleGNlbCBkaXJlY3Rvcnk6ICR7ZXhjZWxEaXJ9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMob3V0cHV0RGlyKSkge1xuICAgICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhvdXRwdXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuRGlyZWN0b3J5KG91dHB1dERpciwgXCIuanNvblwiKTtcblxuICAgICAgICAgICAgLy8g5pu05YGl5aOu55qE5Li05pe25paH5Lu26L+H5ruk5pa55qGIXG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKGV4Y2VsRGlyKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZmlsZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1hsc3ggPSBleHQgPT09IFwiLnhsc3hcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1RlbXBGaWxlID1cbiAgICAgICAgICAgICAgICAgICAgZmlsZS5zdGFydHNXaXRoKFwifiRcIikgfHwgZmlsZS5zdGFydHNXaXRoKFwiflwiKTsgLy8g5Yy56YWN5Lik56eN5Li05pe25paH5Lu25qC85byPXG5cbiAgICAgICAgICAgICAgICAvLyDlj6rkv53nlZkueGxzeOS4lOS4jeaYr+S4tOaXtuaWh+S7tlxuICAgICAgICAgICAgICAgIHJldHVybiBpc1hsc3ggJiYgIWlzVGVtcEZpbGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIEVkaXRvci5EaWFsb2cuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAgXCJbRXhjZWxDb252ZXJ0ZXJdIE5vIC54bHN4IGZpbGVzIGZvdW5kIGluOiBcIiArIGV4Y2VsRGlyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgZmFpbGVkRmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgICBjb25zdCBhbGxFcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2VsUGF0aCA9IHBhdGguam9pbihleGNlbERpciwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25OYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlLCBcIi54bHN4XCIpICsgXCIuanNvblwiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uUGF0aCA9IHBhdGguam9pbihvdXRwdXREaXIsIGpzb25OYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3JrYm9vayA9IHhsc3gucmVhZEZpbGUoZXhjZWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlZXROYW1lcyA9IHdvcmtib29rLlNoZWV0TmFtZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoZWV0TmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB3b3Jrc2hlZXRzIGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY29udmVydFNoZWV0VG9UeXBlZEpzb24oXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lc1swXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoanNvblBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICBgW0V4Y2VsQ29udmVydGVyXSBTdWNjZXNzOiAke2ZpbGV9IC0+ICR7anNvbk5hbWV9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkRmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsRXJyb3JzLnB1c2goYCR7ZmlsZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0V4Y2VsQ29udmVydGVyXSBGYWlsZWQ6ICR7ZmlsZX1gLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVwb3J0ID0gYFtFeGNlbENvbnZlcnRlcl0g6L2s5o2i5a6M5oiQIVxcblxcbuaIkOWKnzogJHtzdWNjZXNzQ291bnR9XFxu5aSx6LSlOiAke2ZhaWxlZEZpbGVzLmxlbmd0aH1gO1xuICAgICAgICAgICAgaWYgKGFsbEVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0ICs9IGBcXG5cXG7plJnor6/or6bmg4U6XFxuJHthbGxFcnJvcnMuam9pbihcIlxcblxcblwiKX1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmFpbGVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIEVkaXRvci5EaWFsb2cuZXJyb3IoXCJbRXhjZWxDb252ZXJ0ZXJdIOi9rOaNouWHuumUmVwiICsgcmVwb3J0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLkRpYWxvZy5pbmZvKFwiW0V4Y2VsQ29udmVydGVyXSDovazmjaLlrozmiJBcIiArIHJlcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbRXhjZWxDb252ZXJ0ZXJdIEdsb2JhbCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgRWRpdG9yLkRpYWxvZy5lcnJvcihcIltFeGNlbENvbnZlcnRlcl0g6ZSZ6K+vXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBtZXRob2RzID0ge1xuICAgIGV4ZWN1dGU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbRXhjZWxDb252ZXJ0ZXJdIEV4ZWN1dGluZy4uLlwiKTtcbiAgICAgICAgZXhjZWxDb252ZXJ0ZXIuY29udmVydEV4Y2VsVG9Kc29uKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbG9hZCgpIHt9XG5leHBvcnQgZnVuY3Rpb24gdW5sb2FkKCkge31cbiJdfQ==