"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unload = exports.load = exports.methods = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const xlsx = __importStar(require("xlsx"));
const excelConverter = {
    cleanDirectory(dir, ext) {
        if (!fs.existsSync(dir))
            return;
        const files = fs.readdirSync(dir);
        files.forEach((file) => {
            if (file.endsWith(ext)) {
                const filePath = path.join(dir, file);
                fs.unlinkSync(filePath); // 删除文件
                console.log(`[Clean] Deleted: ${filePath}`);
            }
        });
    },
    validateType(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return;
        }
        if (type.endsWith("[]")) {
            if (typeof value !== "string") {
                throw new Error(`Expected array (string) but got ${typeof value}`);
            }
            return;
        }
        switch (type) {
            case "int":
            case "number":
                if (isNaN(Number(value))) {
                    throw new Error(`Expected number but got "${value}"`);
                }
                break;
            case "boolean":
                if (typeof value === "string") {
                    const lower = value.toLowerCase();
                    if (lower !== "true" && lower !== "false") {
                        throw new Error(`Expected boolean (true/false) but got "${value}"`);
                    }
                }
                else if (typeof value !== "boolean") {
                    throw new Error(`Expected boolean but got ${typeof value}`);
                }
                break;
            case "json":
                try {
                    const parsed = typeof value === "string" ? JSON.parse(value) : value;
                    if (typeof parsed !== "object" || parsed === null) {
                        throw new Error(`Expected JSON object but got ${typeof parsed}`);
                    }
                }
                catch (e) {
                    throw new Error(`Invalid JSON: ${value}`);
                }
                break;
            case "date":
                const date = new Date(value);
                if (isNaN(date.getTime())) {
                    throw new Error(`Invalid date format: "${value}"`);
                }
                break;
            // Add more type validations as needed
        }
    },
    parseValue(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return null;
        }
        // Validate type first
        this.validateType(value, type, context);
        // Handle array types
        if (type.endsWith("[]")) {
            const elementType = type.replace("[]", "");
            const trimmedValue = value.trim();
            if (trimmedValue === "[]" || trimmedValue === "")
                return [];
            try {
                // Try to parse as JSON array
                const parsed = JSON.parse(trimmedValue);
                if (Array.isArray(parsed)) {
                    return parsed.map((item, index) => this.parseValue(item, elementType, {
                        row: context.row,
                        field: `${context.field}[${index}]`,
                    }));
                }
                return [
                    this.parseValue(parsed, elementType, {
                        row: context.row,
                        field: `${context.field}[0]`,
                    }),
                ];
            }
            catch (e) {
                // Fallback to comma-separated values
                const items = trimmedValue.split(",").map((s) => s.trim());
                return items.map((item, index) => this.parseValue(item, elementType, {
                    row: context.row,
                    field: `${context.field}[${index}]`,
                }));
            }
        }
        // Handle basic types
        switch (type) {
            case "int":
            case "number":
                return Number(value);
            case "string":
                return String(value);
            case "boolean":
                if (typeof value === "string") {
                    return value.toLowerCase() === "true";
                }
                return Boolean(value);
            case "json":
                return typeof value === "string" ? JSON.parse(value) : value;
            case "date":
                return new Date(value).toISOString();
            default:
                return value;
        }
    },
    convertSheetToTypedJson(sheet, filename) {
        const excelData = xlsx.utils.sheet_to_json(sheet, { header: 1 });
        if (excelData.length < 3)
            return [];
        const typeDefs = excelData[0]; // 第一行：数据类型
        const fieldNames = excelData[1]; // 第二行：字段名
        const result = [];
        const errors = [];
        // 从第三行开始解析数据
        for (let i = 2; i < excelData.length; i++) {
            const row = excelData[i];
            const obj = {};
            for (let j = 0; j < fieldNames.length; j++) {
                const fieldName = fieldNames[j];
                if (!fieldName)
                    continue;
                const fieldType = typeDefs[j] || "string";
                const rawValue = row[j];
                try {
                    obj[fieldName] = this.parseValue(rawValue, fieldType, {
                        row: i + 1,
                        field: fieldName,
                    });
                }
                catch (error) {
                    errors.push(`[${filename}] 行 ${i + 1}, 列 "${fieldName}": ${error.message}\n` +
                        `类型: ${fieldType}, 值: ${JSON.stringify(rawValue)}`);
                }
            }
            if (Object.keys(obj).length > 0) {
                result.push(obj);
            }
        }
        if (errors.length > 0) {
            throw new Error(`发现 ${errors.length} 个类型错误:\n${errors.join("\n\n")}`);
        }
        return result;
    },
    convertExcelToJson() {
        try {
            console.log("[ExcelConverter] Starting conversion");
            const excelDir = "D:\\workAndStudy\\CocosCreator\\FormalProject\\res\\data";
            const outputDir = path.join(Editor.Project.path, "assets", "resources", "config");
            if (!fs.existsSync(excelDir)) {
                fs.mkdirSync(excelDir, { recursive: true });
                Editor.Dialog.info(`Created excel directory: ${excelDir}`);
                return;
            }
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            this.cleanDirectory(outputDir, ".json");
            const files = fs
                .readdirSync(excelDir)
                .filter((file) => path.extname(file).toLowerCase() === ".xlsx");
            if (files.length === 0) {
                Editor.Dialog.info("[ExcelConverter] No .xlsx files found in: " + excelDir);
                return;
            }
            let successCount = 0;
            const failedFiles = [];
            const allErrors = [];
            for (const file of files) {
                try {
                    const excelPath = path.join(excelDir, file);
                    const jsonName = path.basename(file, ".xlsx") + ".json";
                    const jsonPath = path.join(outputDir, jsonName);
                    const workbook = xlsx.readFile(excelPath);
                    const sheetNames = workbook.SheetNames;
                    if (sheetNames.length === 0) {
                        throw new Error("No worksheets found");
                    }
                    const data = this.convertSheetToTypedJson(workbook.Sheets[sheetNames[0]], file);
                    fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2));
                    successCount++;
                    console.log(`[ExcelConverter] Success: ${file} -> ${jsonName}`);
                }
                catch (error) {
                    failedFiles.push(file);
                    allErrors.push(`${file}: ${error.message}`);
                    console.error(`[ExcelConverter] Failed: ${file}`, error);
                }
            }
            let report = `[ExcelConverter] 转换完成!\n\n成功: ${successCount}\n失败: ${failedFiles.length}`;
            if (allErrors.length > 0) {
                report += `\n\n错误详情:\n${allErrors.join("\n\n")}`;
            }
            if (failedFiles.length > 0) {
                Editor.Dialog.error("[ExcelConverter] 转换出错" + report);
            }
            else {
                Editor.Dialog.info("[ExcelConverter] 转换完成" + report);
            }
        }
        catch (error) {
            console.error("[ExcelConverter] Global error:", error);
            Editor.Dialog.error("[ExcelConverter] 错误", error.message);
        }
    },
};
exports.methods = {
    execute: async function () {
        console.log("[ExcelConverter] Executing...");
        excelConverter.convertExcelToJson();
        return true;
    },
};
function load() { }
exports.load = load;
function unload() { }
exports.unload = unload;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NvdXJjZS9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYix1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLDJDQUE2QjtBQWtCN0IsTUFBTSxjQUFjLEdBQW1CO0lBQ25DLGNBQWMsQ0FBQyxHQUFXLEVBQUUsR0FBVztRQUNuQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7WUFBRSxPQUFPO1FBRWhDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ25CLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ3RDLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPO2dCQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixRQUFRLEVBQUUsQ0FBQyxDQUFDO2FBQy9DO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsWUFBWSxDQUNSLEtBQVUsRUFDVixJQUFZLEVBQ1osT0FBdUM7UUFFdkMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUUsRUFBRTtZQUN2RCxPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQ1gsbUNBQW1DLE9BQU8sS0FBSyxF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QUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7aUJBQzVEO2FBQ0o7WUFFRCxJQUFJLE1BQU0sR0FBRyxpQ0FBaUMsWUFBWSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN4RixJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUN0QixNQUFNLElBQUksY0FBYyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7YUFDcEQ7WUFFRCxJQUFJLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUN4QixNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsR0FBRyxNQUFNLENBQUMsQ0FBQzthQUN6RDtpQkFBTTtnQkFDSCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxNQUFNLENBQUMsQ0FBQzthQUN4RDtTQUNKO1FBQUMsT0FBTyxLQUFVLEVBQUU7WUFDakIsT0FBTyxDQUFDLEtBQUssQ0FBQyxnQ0FBZ0MsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN2RCxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDN0Q7SUFDTCxDQUFDO0NBQ0osQ0FBQztBQUVXLFFBQUEsT0FBTyxHQUFHO0lBQ25CLE9BQU8sRUFBRSxLQUFLO1FBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1FBQzdDLGNBQWMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ3BDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FDSixDQUFDO0FBRUYsU0FBZ0IsSUFBSSxLQUFJLENBQUM7QUFBekIsb0JBQXlCO0FBQ3pCLFNBQWdCLE1BQU0sS0FBSSxDQUFDO0FBQTNCLHdCQUEyQiIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgKiBhcyB4bHN4IGZyb20gXCJ4bHN4XCI7XHJcblxyXG5pbnRlcmZhY2UgRXhjZWxDb252ZXJ0ZXIge1xyXG4gICAgcGFyc2VWYWx1ZShcclxuICAgICAgICB2YWx1ZTogYW55LFxyXG4gICAgICAgIHR5cGU6IHN0cmluZyxcclxuICAgICAgICBjb250ZXh0OiB7IHJvdzogbnVtYmVyOyBmaWVsZDogc3RyaW5nIH1cclxuICAgICk6IGFueTtcclxuICAgIGNvbnZlcnRTaGVldFRvVHlwZWRKc29uKHNoZWV0OiBhbnksIGZpbGVuYW1lOiBzdHJpbmcpOiBhbnlbXTtcclxuICAgIGNvbnZlcnRFeGNlbFRvSnNvbigpOiB2b2lkO1xyXG4gICAgY2xlYW5EaXJlY3RvcnkoZGlyOiBzdHJpbmcsIGV4dDogc3RyaW5nKTogdm9pZDtcclxuICAgIHZhbGlkYXRlVHlwZShcclxuICAgICAgICB2YWx1ZTogYW55LFxyXG4gICAgICAgIHR5cGU6IHN0cmluZyxcclxuICAgICAgICBjb250ZXh0OiB7IHJvdzogbnVtYmVyOyBmaWVsZDogc3RyaW5nIH1cclxuICAgICk6IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IGV4Y2VsQ29udmVydGVyOiBFeGNlbENvbnZlcnRlciA9IHtcclxuICAgIGNsZWFuRGlyZWN0b3J5KGRpcjogc3RyaW5nLCBleHQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyKTtcclxuICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWxlLmVuZHNXaXRoKGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGRpciwgZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGZpbGVQYXRoKTsgLy8g5Yig6Zmk5paH5Lu2XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0NsZWFuXSBEZWxldGVkOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHZhbGlkYXRlVHlwZShcclxuICAgICAgICB2YWx1ZTogYW55LFxyXG4gICAgICAgIHR5cGU6IHN0cmluZyxcclxuICAgICAgICBjb250ZXh0OiB7IHJvdzogbnVtYmVyOyBmaWVsZDogc3RyaW5nIH1cclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlLmVuZHNXaXRoKFwiW11cIikpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhcnJheSAoc3RyaW5nKSBidXQgZ290ICR7dHlwZW9mIHZhbHVlfWBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbnRcIjpcclxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKE51bWJlcih2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBudW1iZXIgYnV0IGdvdCBcIiR7dmFsdWV9XCJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXIgIT09IFwidHJ1ZVwiICYmIGxvd2VyICE9PSBcImZhbHNlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGJvb2xlYW4gKHRydWUvZmFsc2UpIGJ1dCBnb3QgXCIke3ZhbHVlfVwiYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiBidXQgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UodmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgIT09IFwib2JqZWN0XCIgfHwgcGFyc2VkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBKU09OIG9iamVjdCBidXQgZ290ICR7dHlwZW9mIHBhcnNlZH1gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OOiAke3ZhbHVlfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIGZvcm1hdDogXCIke3ZhbHVlfVwiYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy8gQWRkIG1vcmUgdHlwZSB2YWxpZGF0aW9ucyBhcyBuZWVkZWRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlVmFsdWUoXHJcbiAgICAgICAgdmFsdWU6IGFueSxcclxuICAgICAgICB0eXBlOiBzdHJpbmcsXHJcbiAgICAgICAgY29udGV4dDogeyByb3c6IG51bWJlcjsgZmllbGQ6IHN0cmluZyB9XHJcbiAgICApOiBhbnkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgdHlwZSBmaXJzdFxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCB0eXBlLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGFycmF5IHR5cGVzXHJcbiAgICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoXCJbXVwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IHR5cGUucmVwbGFjZShcIltdXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICBjb25zdCB0cmltbWVkVmFsdWUgPSB2YWx1ZS50cmltKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHJpbW1lZFZhbHVlID09PSBcIltdXCIgfHwgdHJpbW1lZFZhbHVlID09PSBcIlwiKSByZXR1cm4gW107XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIEpTT04gYXJyYXlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UodHJpbW1lZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkLm1hcCgoaXRlbSwgaW5kZXgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VWYWx1ZShpdGVtLCBlbGVtZW50VHlwZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBjb250ZXh0LnJvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBgJHtjb250ZXh0LmZpZWxkfVske2luZGV4fV1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VWYWx1ZShwYXJzZWQsIGVsZW1lbnRUeXBlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogY29udGV4dC5yb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBgJHtjb250ZXh0LmZpZWxkfVswXWAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRyaW1tZWRWYWx1ZS5zcGxpdChcIixcIikubWFwKChzOiBhbnkpID0+IHMudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW06IGFueSwgaW5kZXg6IGFueSkgPT5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVmFsdWUoaXRlbSwgZWxlbWVudFR5cGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBjb250ZXh0LnJvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGAke2NvbnRleHQuZmllbGR9WyR7aW5kZXh9XWAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBiYXNpYyB0eXBlc1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiaW50XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZSh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbnZlcnRTaGVldFRvVHlwZWRKc29uKHNoZWV0OiBhbnksIGZpbGVuYW1lOiBzdHJpbmcpOiBhbnlbXSB7XHJcbiAgICAgICAgY29uc3QgZXhjZWxEYXRhID0geGxzeC51dGlscy5zaGVldF90b19qc29uKHNoZWV0LCB7IGhlYWRlcjogMSB9KTtcclxuXHJcbiAgICAgICAgaWYgKGV4Y2VsRGF0YS5sZW5ndGggPCAzKSByZXR1cm4gW107XHJcblxyXG4gICAgICAgIGNvbnN0IHR5cGVEZWZzOiBhbnkgPSBleGNlbERhdGFbMF07IC8vIOesrOS4gOihjO+8muaVsOaNruexu+Wei1xyXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXM6IGFueSA9IGV4Y2VsRGF0YVsxXTsgLy8g56ys5LqM6KGM77ya5a2X5q615ZCNXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgICAgICAvLyDku47nrKzkuInooYzlvIDlp4vop6PmnpDmlbDmja5cclxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGV4Y2VsRGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCByb3c6IGFueSA9IGV4Y2VsRGF0YVtpXTtcclxuICAgICAgICAgICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmllbGROYW1lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGROYW1lc1tqXTtcclxuICAgICAgICAgICAgICAgIGlmICghZmllbGROYW1lKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSB0eXBlRGVmc1tqXSB8fCBcInN0cmluZ1wiO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSByb3dbal07XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbZmllbGROYW1lXSA9IHRoaXMucGFyc2VWYWx1ZShyYXdWYWx1ZSwgZmllbGRUeXBlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogaSArIDEsIC8vIEV4Y2Vs6KGM5Y+35LuOMeW8gOWni1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBgWyR7ZmlsZW5hbWV9XSDooYwgJHtpICsgMX0sIOWIlyBcIiR7ZmllbGROYW1lfVwiOiAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBg57G75Z6LOiAke2ZpZWxkVHlwZX0sIOWAvDogJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1gXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgIGDlj5HnjrAgJHtlcnJvcnMubGVuZ3RofSDkuKrnsbvlnovplJnor686XFxuJHtlcnJvcnMuam9pbihcIlxcblxcblwiKX1gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBjb252ZXJ0RXhjZWxUb0pzb24oKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbRXhjZWxDb252ZXJ0ZXJdIFN0YXJ0aW5nIGNvbnZlcnNpb25cIik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBleGNlbERpciA9XHJcbiAgICAgICAgICAgICAgICBcIkQ6XFxcXHdvcmtBbmRTdHVkeVxcXFxDb2Nvc0NyZWF0b3JcXFxcRm9ybWFsUHJvamVjdFxcXFxyZXNcXFxcZGF0YVwiO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXREaXIgPSBwYXRoLmpvaW4oXHJcbiAgICAgICAgICAgICAgICBFZGl0b3IuUHJvamVjdC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgXCJhc3NldHNcIixcclxuICAgICAgICAgICAgICAgIFwicmVzb3VyY2VzXCIsXHJcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZXhjZWxEaXIpKSB7XHJcbiAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMoZXhjZWxEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgRWRpdG9yLkRpYWxvZy5pbmZvKGBDcmVhdGVkIGV4Y2VsIGRpcmVjdG9yeTogJHtleGNlbERpcn1gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG91dHB1dERpcikpIHtcclxuICAgICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhvdXRwdXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNsZWFuRGlyZWN0b3J5KG91dHB1dERpciwgXCIuanNvblwiKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZnNcclxuICAgICAgICAgICAgICAgIC5yZWFkZGlyU3luYyhleGNlbERpcilcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGZpbGUpID0+IHBhdGguZXh0bmFtZShmaWxlKS50b0xvd2VyQ2FzZSgpID09PSBcIi54bHN4XCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgRWRpdG9yLkRpYWxvZy5pbmZvKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiW0V4Y2VsQ29udmVydGVyXSBObyAueGxzeCBmaWxlcyBmb3VuZCBpbjogXCIgKyBleGNlbERpclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZEZpbGVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBhbGxFcnJvcnM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjZWxQYXRoID0gcGF0aC5qb2luKGV4Y2VsRGlyLCBmaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSwgXCIueGxzeFwiKSArIFwiLmpzb25cIjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uUGF0aCA9IHBhdGguam9pbihvdXRwdXREaXIsIGpzb25OYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29ya2Jvb2sgPSB4bHN4LnJlYWRGaWxlKGV4Y2VsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlZXROYW1lcyA9IHdvcmtib29rLlNoZWV0TmFtZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGVldE5hbWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB3b3Jrc2hlZXRzIGZvdW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY29udmVydFNoZWV0VG9UeXBlZEpzb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtib29rLlNoZWV0c1tzaGVldE5hbWVzWzBdXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhqc29uUGF0aCwgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgYFtFeGNlbENvbnZlcnRlcl0gU3VjY2VzczogJHtmaWxlfSAtPiAke2pzb25OYW1lfWBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZEZpbGVzLnB1c2goZmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsRXJyb3JzLnB1c2goYCR7ZmlsZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbRXhjZWxDb252ZXJ0ZXJdIEZhaWxlZDogJHtmaWxlfWAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHJlcG9ydCA9IGBbRXhjZWxDb252ZXJ0ZXJdIOi9rOaNouWujOaIkCFcXG5cXG7miJDlip86ICR7c3VjY2Vzc0NvdW50fVxcbuWksei0pTogJHtmYWlsZWRGaWxlcy5sZW5ndGh9YDtcclxuICAgICAgICAgICAgaWYgKGFsbEVycm9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXBvcnQgKz0gYFxcblxcbumUmeivr+ivpuaDhTpcXG4ke2FsbEVycm9ycy5qb2luKFwiXFxuXFxuXCIpfWA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmYWlsZWRGaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmVycm9yKFwiW0V4Y2VsQ29udmVydGVyXSDovazmjaLlh7rplJlcIiArIHJlcG9ydCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmluZm8oXCJbRXhjZWxDb252ZXJ0ZXJdIOi9rOaNouWujOaIkFwiICsgcmVwb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltFeGNlbENvbnZlcnRlcl0gR2xvYmFsIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgIEVkaXRvci5EaWFsb2cuZXJyb3IoXCJbRXhjZWxDb252ZXJ0ZXJdIOmUmeivr1wiLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1ldGhvZHMgPSB7XHJcbiAgICBleGVjdXRlOiBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJbRXhjZWxDb252ZXJ0ZXJdIEV4ZWN1dGluZy4uLlwiKTtcclxuICAgICAgICBleGNlbENvbnZlcnRlci5jb252ZXJ0RXhjZWxUb0pzb24oKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbG9hZCgpIHt9XHJcbmV4cG9ydCBmdW5jdGlvbiB1bmxvYWQoKSB7fVxyXG4iXX0=