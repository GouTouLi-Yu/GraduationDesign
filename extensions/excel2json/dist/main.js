"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unload = exports.load = exports.methods = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const xlsx = __importStar(require("xlsx"));
const excelConverter = {
    cleanDirectory(dir, ext) {
        if (!fs.existsSync(dir))
            return;
        const files = fs.readdirSync(dir);
        files.forEach((file) => {
            if (file.endsWith(ext)) {
                const filePath = path.join(dir, file);
                fs.unlinkSync(filePath); // 删除文件
                console.log(`[Clean] Deleted: ${filePath}`);
            }
        });
    },
    validateType(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return;
        }
        if (type.endsWith("[]")) {
            if (typeof value !== "string") {
                throw new Error(`Expected array (string) but got ${typeof value}`);
            }
            return;
        }
        switch (type) {
            case "int":
            case "number":
                if (isNaN(Number(value))) {
                    throw new Error(`Expected number but got "${value}"`);
                }
                break;
            case "boolean":
                if (typeof value === "string") {
                    const lower = value.toLowerCase();
                    if (lower !== "true" && lower !== "false") {
                        throw new Error(`Expected boolean (true/false) but got "${value}"`);
                    }
                }
                else if (typeof value !== "boolean") {
                    throw new Error(`Expected boolean but got ${typeof value}`);
                }
                break;
            case "json":
                try {
                    const parsed = typeof value === "string" ? JSON.parse(value) : value;
                    if (typeof parsed !== "object" || parsed === null) {
                        throw new Error(`Expected JSON object but got ${typeof parsed}`);
                    }
                }
                catch (e) {
                    throw new Error(`Invalid JSON: ${value}`);
                }
                break;
            case "date":
                const date = new Date(value);
                if (isNaN(date.getTime())) {
                    throw new Error(`Invalid date format: "${value}"`);
                }
                break;
            // Add more type validations as needed
        }
    },
    parseValue(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return null;
        }
        // Validate type first
        this.validateType(value, type, context);
        // Handle array types
        if (type.endsWith("[]")) {
            const elementType = type.replace("[]", "");
            const trimmedValue = value.trim();
            if (trimmedValue === "[]" || trimmedValue === "")
                return [];
            try {
                // Try to parse as JSON array
                const parsed = JSON.parse(trimmedValue);
                if (Array.isArray(parsed)) {
                    return parsed.map((item, index) => this.parseValue(item, elementType, {
                        row: context.row,
                        field: `${context.field}[${index}]`,
                    }));
                }
                return [
                    this.parseValue(parsed, elementType, {
                        row: context.row,
                        field: `${context.field}[0]`,
                    }),
                ];
            }
            catch (e) {
                // Fallback to comma-separated values
                const items = trimmedValue.split(",").map((s) => s.trim());
                return items.map((item, index) => this.parseValue(item, elementType, {
                    row: context.row,
                    field: `${context.field}[${index}]`,
                }));
            }
        }
        //
        // Handle basic types
        switch (type) {
            case "int":
            case "number":
                return Number(value);
            case "string":
                return String(value);
            case "boolean":
                if (typeof value === "string") {
                    return value.toLowerCase() === "true";
                }
                return Boolean(value);
            case "json":
                return typeof value === "string" ? JSON.parse(value) : value;
            case "date":
                return new Date(value).toISOString();
            default:
                return value;
        }
    },
    convertSheetToTypedJson(sheet, filename) {
        const excelData = xlsx.utils.sheet_to_json(sheet, { header: 1 });
        if (excelData.length < 3)
            return [];
        const typeDefs = excelData[0]; // 第一行：数据类型
        const fieldNames = excelData[1]; // 第二行：字段名
        const result = [];
        const errors = [];
        // 从第三行开始解析数据
        for (let i = 2; i < excelData.length; i++) {
            const row = excelData[i];
            const obj = {};
            for (let j = 0; j < fieldNames.length; j++) {
                const fieldName = fieldNames[j];
                if (!fieldName)
                    continue;
                const fieldType = typeDefs[j] || "string";
                const rawValue = row[j];
                try {
                    obj[fieldName] = this.parseValue(rawValue, fieldType, {
                        row: i + 1,
                        field: fieldName,
                    });
                }
                catch (error) {
                    errors.push(`[${filename}] 行 ${i + 1}, 列 "${fieldName}": ${error.message}\n` +
                        `类型: ${fieldType}, 值: ${JSON.stringify(rawValue)}`);
                }
            }
            if (Object.keys(obj).length > 0) {
                result.push(obj);
            }
        }
        if (errors.length > 0) {
            throw new Error(`发现 ${errors.length} 个类型错误:\n${errors.join("\n\n")}`);
        }
        return result;
    },
    convertExcelToJson() {
        try {
            console.log("[ExcelConverter] Starting conversion");
            // 获取项目根目录的上一级目录
            const projectParentDir = path.dirname(Editor.Project.path);
            // 设置Excel目录为上一级目录的res/data
            const excelDir = path.join(projectParentDir, "res", "data");
            const outputDir = path.join(Editor.Project.path, "assets", "resources", "config");
            if (!fs.existsSync(excelDir)) {
                fs.mkdirSync(excelDir, { recursive: true });
                Editor.Dialog.info(`Created excel directory: ${excelDir}`);
                return;
            }
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            this.cleanDirectory(outputDir, ".json");
            const files = fs
                .readdirSync(excelDir)
                .filter((file) => path.extname(file).toLowerCase() === ".xlsx" &&
                !file.startsWith("~"));
            if (files.length === 0) {
                Editor.Dialog.info("[ExcelConverter] No .xlsx files found in: " + excelDir);
                return;
            }
            let successCount = 0;
            const failedFiles = [];
            const allErrors = [];
            for (const file of files) {
                try {
                    const excelPath = path.join(excelDir, file);
                    const jsonName = path.basename(file, ".xlsx") + ".json";
                    const jsonPath = path.join(outputDir, jsonName);
                    const workbook = xlsx.readFile(excelPath);
                    const sheetNames = workbook.SheetNames;
                    if (sheetNames.length === 0) {
                        throw new Error("No worksheets found");
                    }
                    const data = this.convertSheetToTypedJson(workbook.Sheets[sheetNames[0]], file);
                    fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2));
                    successCount++;
                    console.log(`[ExcelConverter] Success: ${file} -> ${jsonName}`);
                }
                catch (error) {
                    failedFiles.push(file);
                    allErrors.push(`${file}: ${error.message}`);
                    console.error(`[ExcelConverter] Failed: ${file}`, error);
                }
            }
            let report = `[ExcelConverter] 转换完成!\n\n成功: ${successCount}\n失败: ${failedFiles.length}`;
            if (allErrors.length > 0) {
                report += `\n\n错误详情:\n${allErrors.join("\n\n")}`;
            }
            if (failedFiles.length > 0) {
                Editor.Dialog.error("[ExcelConverter] 转换出错" + report);
            }
            else {
                Editor.Dialog.info("[ExcelConverter] 转换完成" + report);
            }
        }
        catch (error) {
            console.error("[ExcelConverter] Global error:", error);
            Editor.Dialog.error("[ExcelConverter] 错误", error.message);
        }
    },
};
exports.methods = {
    execute: async function () {
        console.log("[ExcelConverter] Executing...");
        excelConverter.convertExcelToJson();
        return true;
    },
};
function load() { }
exports.load = load;
function unload() { }
exports.unload = unload;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NvdXJjZS9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYix1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLDJDQUE2QjtBQWtCN0IsTUFBTSxjQUFjLEdBQW1CO0lBQ25DLGNBQWMsQ0FBQyxHQUFXLEVBQUUsR0FBVztRQUNuQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7WUFBRSxPQUFPO1FBRWhDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ25CLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ3RDLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPO2dCQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixRQUFRLEVBQUUsQ0FBQyxDQUFDO2FBQy9DO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsWUFBWSxDQUNSLEtBQVUsRUFDVixJQUFZLEVBQ1osT0FBdUM7UUFFdkMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUUsRUFBRTtZQUN2RCxPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQ1gsbUNBQW1DLE9BQU8sS0FBSyxF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SSxDQUFDO0lBQ2hCLENBQUM7Q0FDSixDQUFDO0FBRUYsU0FBZ0IsSUFBSSxLQUFJLENBQUM7QUFBekIsb0JBQXlCO0FBQ3pCLFNBQWdCLE1BQU0sS0FBSSxDQUFDO0FBQTNCLHdCQUEyQiIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyB4bHN4IGZyb20gXCJ4bHN4XCI7XG5cbmludGVyZmFjZSBFeGNlbENvbnZlcnRlciB7XG4gICAgcGFyc2VWYWx1ZShcbiAgICAgICAgdmFsdWU6IGFueSxcbiAgICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAgICBjb250ZXh0OiB7IHJvdzogbnVtYmVyOyBmaWVsZDogc3RyaW5nIH1cbiAgICApOiBhbnk7XG4gICAgY29udmVydFNoZWV0VG9UeXBlZEpzb24oc2hlZXQ6IGFueSwgZmlsZW5hbWU6IHN0cmluZyk6IGFueVtdO1xuICAgIGNvbnZlcnRFeGNlbFRvSnNvbigpOiB2b2lkO1xuICAgIGNsZWFuRGlyZWN0b3J5KGRpcjogc3RyaW5nLCBleHQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgdmFsaWRhdGVUeXBlKFxuICAgICAgICB2YWx1ZTogYW55LFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNvbnRleHQ6IHsgcm93OiBudW1iZXI7IGZpZWxkOiBzdHJpbmcgfVxuICAgICk6IHZvaWQ7XG59XG5cbmNvbnN0IGV4Y2VsQ29udmVydGVyOiBFeGNlbENvbnZlcnRlciA9IHtcbiAgICBjbGVhbkRpcmVjdG9yeShkaXI6IHN0cmluZywgZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHJldHVybjtcblxuICAgICAgICBjb25zdCBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKGRpcik7XG4gICAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlLmVuZHNXaXRoKGV4dCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihkaXIsIGZpbGUpO1xuICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMoZmlsZVBhdGgpOyAvLyDliKDpmaTmlofku7ZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0NsZWFuXSBEZWxldGVkOiAke2ZpbGVQYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGVUeXBlKFxuICAgICAgICB2YWx1ZTogYW55LFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNvbnRleHQ6IHsgcm93OiBudW1iZXI7IGZpZWxkOiBzdHJpbmcgfVxuICAgICk6IHZvaWQge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoXCJbXVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFycmF5IChzdHJpbmcpIGJ1dCBnb3QgJHt0eXBlb2YgdmFsdWV9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBudW1iZXIgYnV0IGdvdCBcIiR7dmFsdWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXIgIT09IFwidHJ1ZVwiICYmIGxvd2VyICE9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYm9vbGVhbiAodHJ1ZS9mYWxzZSkgYnV0IGdvdCBcIiR7dmFsdWV9XCJgXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiBidXQgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkICE9PSBcIm9iamVjdFwiIHx8IHBhcnNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBKU09OIG9iamVjdCBidXQgZ290ICR7dHlwZW9mIHBhcnNlZH1gXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0ZSBmb3JtYXQ6IFwiJHt2YWx1ZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEFkZCBtb3JlIHR5cGUgdmFsaWRhdGlvbnMgYXMgbmVlZGVkXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VWYWx1ZShcbiAgICAgICAgdmFsdWU6IGFueSxcbiAgICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAgICBjb250ZXh0OiB7IHJvdzogbnVtYmVyOyBmaWVsZDogc3RyaW5nIH1cbiAgICApOiBhbnkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSB0eXBlIGZpcnN0XG4gICAgICAgIHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCB0eXBlLCBjb250ZXh0KTtcblxuICAgICAgICAvLyBIYW5kbGUgYXJyYXkgdHlwZXNcbiAgICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoXCJbXVwiKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSB0eXBlLnJlcGxhY2UoXCJbXVwiLCBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRWYWx1ZSA9IHZhbHVlLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKHRyaW1tZWRWYWx1ZSA9PT0gXCJbXVwiIHx8IHRyaW1tZWRWYWx1ZSA9PT0gXCJcIikgcmV0dXJuIFtdO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBKU09OIGFycmF5XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh0cmltbWVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC5tYXAoKGl0ZW0sIGluZGV4KSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVZhbHVlKGl0ZW0sIGVsZW1lbnRUeXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBjb250ZXh0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogYCR7Y29udGV4dC5maWVsZH1bJHtpbmRleH1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VWYWx1ZShwYXJzZWQsIGVsZW1lbnRUeXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IGNvbnRleHQucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGAke2NvbnRleHQuZmllbGR9WzBdYCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0cmltbWVkVmFsdWUuc3BsaXQoXCIsXCIpLm1hcCgoczogYW55KSA9PiBzLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbTogYW55LCBpbmRleDogYW55KSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVmFsdWUoaXRlbSwgZWxlbWVudFR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogY29udGV4dC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogYCR7Y29udGV4dC5maWVsZH1bJHtpbmRleH1dYCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGFuZGxlIGJhc2ljIHR5cGVzXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImludFwiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29udmVydFNoZWV0VG9UeXBlZEpzb24oc2hlZXQ6IGFueSwgZmlsZW5hbWU6IHN0cmluZyk6IGFueVtdIHtcbiAgICAgICAgY29uc3QgZXhjZWxEYXRhID0geGxzeC51dGlscy5zaGVldF90b19qc29uKHNoZWV0LCB7IGhlYWRlcjogMSB9KTtcblxuICAgICAgICBpZiAoZXhjZWxEYXRhLmxlbmd0aCA8IDMpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCB0eXBlRGVmczogYW55ID0gZXhjZWxEYXRhWzBdOyAvLyDnrKzkuIDooYzvvJrmlbDmja7nsbvlnotcbiAgICAgICAgY29uc3QgZmllbGROYW1lczogYW55ID0gZXhjZWxEYXRhWzFdOyAvLyDnrKzkuozooYzvvJrlrZfmrrXlkI1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyDku47nrKzkuInooYzlvIDlp4vop6PmnpDmlbDmja5cbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBleGNlbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdzogYW55ID0gZXhjZWxEYXRhW2ldO1xuICAgICAgICAgICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWVsZE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGROYW1lc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkTmFtZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSB0eXBlRGVmc1tqXSB8fCBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcm93W2pdO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ZpZWxkTmFtZV0gPSB0aGlzLnBhcnNlVmFsdWUocmF3VmFsdWUsIGZpZWxkVHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBpICsgMSwgLy8gRXhjZWzooYzlj7fku44x5byA5aeLXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFske2ZpbGVuYW1lfV0g6KGMICR7aSArIDF9LCDliJcgXCIke2ZpZWxkTmFtZX1cIjogJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYOexu+WeizogJHtmaWVsZFR5cGV9LCDlgLw6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGDlj5HnjrAgJHtlcnJvcnMubGVuZ3RofSDkuKrnsbvlnovplJnor686XFxuJHtlcnJvcnMuam9pbihcIlxcblxcblwiKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgY29udmVydEV4Y2VsVG9Kc29uKCk6IHZvaWQge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbRXhjZWxDb252ZXJ0ZXJdIFN0YXJ0aW5nIGNvbnZlcnNpb25cIik7XG5cbiAgICAgICAgICAgIC8vIOiOt+WPlumhueebruagueebruW9leeahOS4iuS4gOe6p+ebruW9lVxuICAgICAgICAgICAgY29uc3QgcHJvamVjdFBhcmVudERpciA9IHBhdGguZGlybmFtZShFZGl0b3IuUHJvamVjdC5wYXRoKTtcbiAgICAgICAgICAgIC8vIOiuvue9rkV4Y2Vs55uu5b2V5Li65LiK5LiA57qn55uu5b2V55qEcmVzL2RhdGFcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VsRGlyID0gcGF0aC5qb2luKHByb2plY3RQYXJlbnREaXIsIFwicmVzXCIsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dERpciA9IHBhdGguam9pbihcbiAgICAgICAgICAgICAgICBFZGl0b3IuUHJvamVjdC5wYXRoLFxuICAgICAgICAgICAgICAgIFwiYXNzZXRzXCIsXG4gICAgICAgICAgICAgICAgXCJyZXNvdXJjZXNcIixcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZXhjZWxEaXIpKSB7XG4gICAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKGV4Y2VsRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmluZm8oYENyZWF0ZWQgZXhjZWwgZGlyZWN0b3J5OiAke2V4Y2VsRGlyfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG91dHB1dERpcikpIHtcbiAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMob3V0cHV0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhbkRpcmVjdG9yeShvdXRwdXREaXIsIFwiLmpzb25cIik7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZnNcbiAgICAgICAgICAgICAgICAucmVhZGRpclN5bmMoZXhjZWxEaXIpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKGZpbGUpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmV4dG5hbWUoZmlsZSkudG9Mb3dlckNhc2UoKSA9PT0gXCIueGxzeFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhZmlsZS5zdGFydHNXaXRoKFwiflwiKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIFwiW0V4Y2VsQ29udmVydGVyXSBObyAueGxzeCBmaWxlcyBmb3VuZCBpbjogXCIgKyBleGNlbERpclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZEZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWxsRXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNlbFBhdGggPSBwYXRoLmpvaW4oZXhjZWxEaXIsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSwgXCIueGxzeFwiKSArIFwiLmpzb25cIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNvblBhdGggPSBwYXRoLmpvaW4ob3V0cHV0RGlyLCBqc29uTmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29ya2Jvb2sgPSB4bHN4LnJlYWRGaWxlKGV4Y2VsUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0TmFtZXMgPSB3b3JrYm9vay5TaGVldE5hbWVzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGVldE5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gd29ya3NoZWV0cyBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNvbnZlcnRTaGVldFRvVHlwZWRKc29uKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Jvb2suU2hlZXRzW3NoZWV0TmFtZXNbMF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGpzb25QYXRoLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFtFeGNlbENvbnZlcnRlcl0gU3VjY2VzczogJHtmaWxlfSAtPiAke2pzb25OYW1lfWBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZEZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9ycy5wdXNoKGAke2ZpbGV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtFeGNlbENvbnZlcnRlcl0gRmFpbGVkOiAke2ZpbGV9YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlcG9ydCA9IGBbRXhjZWxDb252ZXJ0ZXJdIOi9rOaNouWujOaIkCFcXG5cXG7miJDlip86ICR7c3VjY2Vzc0NvdW50fVxcbuWksei0pTogJHtmYWlsZWRGaWxlcy5sZW5ndGh9YDtcbiAgICAgICAgICAgIGlmIChhbGxFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlcG9ydCArPSBgXFxuXFxu6ZSZ6K+v6K+m5oOFOlxcbiR7YWxsRXJyb3JzLmpvaW4oXCJcXG5cXG5cIil9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZhaWxlZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmVycm9yKFwiW0V4Y2VsQ29udmVydGVyXSDovazmjaLlh7rplJlcIiArIHJlcG9ydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEVkaXRvci5EaWFsb2cuaW5mbyhcIltFeGNlbENvbnZlcnRlcl0g6L2s5o2i5a6M5oiQXCIgKyByZXBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0V4Y2VsQ29udmVydGVyXSBHbG9iYWwgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIEVkaXRvci5EaWFsb2cuZXJyb3IoXCJbRXhjZWxDb252ZXJ0ZXJdIOmUmeivr1wiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgbWV0aG9kcyA9IHtcbiAgICBleGVjdXRlOiBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0V4Y2VsQ29udmVydGVyXSBFeGVjdXRpbmcuLi5cIik7XG4gICAgICAgIGV4Y2VsQ29udmVydGVyLmNvbnZlcnRFeGNlbFRvSnNvbigpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWQoKSB7fVxuZXhwb3J0IGZ1bmN0aW9uIHVubG9hZCgpIHt9XG4iXX0=