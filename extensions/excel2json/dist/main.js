"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unload = exports.load = exports.methods = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const xlsx = __importStar(require("xlsx"));
const excelConverter = {
    cleanDirectory(dir, ext) {
        if (!fs.existsSync(dir))
            return;
        const files = fs.readdirSync(dir);
        files.forEach((file) => {
            if (file.endsWith(ext)) {
                const filePath = path.join(dir, file);
                fs.unlinkSync(filePath); // 删除文件
                console.log(`[Clean] Deleted: ${filePath}`);
            }
        });
    },
    validateType(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return;
        }
        if (type.endsWith("[]")) {
            if (typeof value !== "string") {
                throw new Error(`Expected array (string) but got ${typeof value}`);
            }
            return;
        }
        switch (type) {
            case "int":
            case "number":
                if (isNaN(Number(value))) {
                    throw new Error(`Expected number but got "${value}"`);
                }
                break;
            case "boolean":
                if (typeof value === "string") {
                    const lower = value.toLowerCase();
                    if (lower !== "true" && lower !== "false") {
                        throw new Error(`Expected boolean (true/false) but got "${value}"`);
                    }
                }
                else if (typeof value !== "boolean") {
                    throw new Error(`Expected boolean but got ${typeof value}`);
                }
                break;
            case "json":
                try {
                    const parsed = typeof value === "string" ? JSON.parse(value) : value;
                    if (typeof parsed !== "object" || parsed === null) {
                        throw new Error(`Expected JSON object but got ${typeof parsed}`);
                    }
                }
                catch (e) {
                    throw new Error(`Invalid JSON: ${value}`);
                }
                break;
            case "date":
                const date = new Date(value);
                if (isNaN(date.getTime())) {
                    throw new Error(`Invalid date format: "${value}"`);
                }
                break;
            // Add more type validations as needed
        }
    },
    parseValue(value, type, context) {
        if (value === undefined || value === null || value === "") {
            return null;
        }
        // Validate type first
        this.validateType(value, type, context);
        // Handle array types
        if (type.endsWith("[]")) {
            const elementType = type.replace("[]", "");
            const trimmedValue = value.trim();
            if (trimmedValue === "[]" || trimmedValue === "")
                return [];
            try {
                // Try to parse as JSON array
                const parsed = JSON.parse(trimmedValue);
                if (Array.isArray(parsed)) {
                    return parsed.map((item, index) => this.parseValue(item, elementType, {
                        row: context.row,
                        field: `${context.field}[${index}]`,
                    }));
                }
                return [
                    this.parseValue(parsed, elementType, {
                        row: context.row,
                        field: `${context.field}[0]`,
                    }),
                ];
            }
            catch (e) {
                // Fallback to comma-separated values
                const items = trimmedValue.split(",").map((s) => s.trim());
                return items.map((item, index) => this.parseValue(item, elementType, {
                    row: context.row,
                    field: `${context.field}[${index}]`,
                }));
            }
        }
        //
        // Handle basic types
        switch (type) {
            case "int":
            case "number":
                return Number(value);
            case "string":
                return String(value);
            case "boolean":
                if (typeof value === "string") {
                    return value.toLowerCase() === "true";
                }
                return Boolean(value);
            case "json":
                return typeof value === "string" ? JSON.parse(value) : value;
            case "date":
                return new Date(value).toISOString();
            default:
                return value;
        }
    },
    convertSheetToTypedJson(sheet, filename) {
        const excelData = xlsx.utils.sheet_to_json(sheet, { header: 1 });
        if (excelData.length < 3)
            return [];
        console.log("excelData ==== ", excelData);
        const typeDefs = excelData[1]; // 第一行：数据类型
        const fieldNames = excelData[2]; // 第二行：字段名
        const result = [];
        const errors = [];
        // 从第三行开始解析数据
        for (let i = 3; i < excelData.length; i++) {
            const row = excelData[i];
            if (row[0] == "$end$") {
                break;
            }
            const obj = {};
            for (let j = 0; j < fieldNames.length; j++) {
                const fieldName = fieldNames[j];
                if (!fieldName)
                    continue;
                const fieldType = typeDefs[j] || "string";
                const rawValue = row[j];
                try {
                    obj[fieldName] = this.parseValue(rawValue, fieldType, {
                        row: i + 1,
                        field: fieldName,
                    });
                }
                catch (error) {
                    errors.push(`[${filename}] 行 ${i + 1}, 列 "${fieldName}": ${error.message}\n` +
                        `类型: ${fieldType}, 值: ${JSON.stringify(rawValue)}`);
                }
            }
            if (Object.keys(obj).length > 0) {
                result.push(obj);
            }
        }
        if (errors.length > 0) {
            throw new Error(`发现 ${errors.length} 个类型错误:\n${errors.join("\n\n")}`);
        }
        return result;
    },
    convertExcelToJson() {
        try {
            console.log("[ExcelConverter] Starting conversion");
            // 获取项目根目录的上一级目录
            const projectParentDir = path.dirname(Editor.Project.path);
            // 设置Excel目录为上一级目录的res/data
            const excelDir = path.join(projectParentDir, "projectRes", "data");
            const outputDir = path.join(Editor.Project.path, "assets", "resources", "config");
            if (!fs.existsSync(excelDir)) {
                fs.mkdirSync(excelDir, { recursive: true });
                Editor.Dialog.info(`Created excel directory: ${excelDir}`);
                return;
            }
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            this.cleanDirectory(outputDir, ".json");
            const files = fs.readdirSync(excelDir).filter((file) => {
                const ext = path.extname(file).toLowerCase();
                const isXlsx = ext === ".xlsx";
                const isTempFile = file.startsWith("~$") || file.startsWith("~"); // 匹配两种临时文件格式
                // 只保留.xlsx且不是临时文件
                return isXlsx && !isTempFile;
            });
            if (files.length === 0) {
                Editor.Dialog.info("[ExcelConverter] No .xlsx files found in: " + excelDir);
                return;
            }
            let successCount = 0;
            const failedFiles = [];
            const allErrors = [];
            for (const file of files) {
                try {
                    const excelPath = path.join(excelDir, file);
                    const jsonName = path.basename(file, ".xlsx") + ".json";
                    const jsonPath = path.join(outputDir, jsonName);
                    const workbook = xlsx.readFile(excelPath);
                    const sheetNames = workbook.SheetNames;
                    if (sheetNames.length === 0) {
                        throw new Error("No worksheets found");
                    }
                    const data = this.convertSheetToTypedJson(workbook.Sheets[sheetNames[0]], file);
                    fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2));
                    successCount++;
                    console.log(`[ExcelConverter] Success: ${file} -> ${jsonName}`);
                }
                catch (error) {
                    failedFiles.push(file);
                    allErrors.push(`${file}: ${error.message}`);
                    console.error(`[ExcelConverter] Failed: ${file}`, error);
                }
            }
            let report = `[ExcelConverter] 转换完成!\n\n成功: ${successCount}\n失败: ${failedFiles.length}`;
            if (allErrors.length > 0) {
                report += `\n\n错误详情:\n${allErrors.join("\n\n")}`;
            }
            if (failedFiles.length > 0) {
                Editor.Dialog.error("[ExcelConverter] 转换出错" + report);
            }
            else {
                Editor.Dialog.info("[ExcelConverter] 转换完成" + report);
            }
        }
        catch (error) {
            console.error("[ExcelConverter] Global error:", error);
            Editor.Dialog.error("[ExcelConverter] 错误", error.message);
        }
    },
};
exports.methods = {
    execute: async function () {
        console.log("[ExcelConverter] Executing...");
        excelConverter.convertExcelToJson();
        return true;
    },
};
function load() { }
exports.load = load;
function unload() { }
exports.unload = unload;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NvdXJjZS9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYix1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLDJDQUE2QjtBQWtCN0IsTUFBTSxjQUFjLEdBQW1CO0lBQ25DLGNBQWMsQ0FBQyxHQUFXLEVBQUUsR0FBVztRQUNuQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7WUFBRSxPQUFPO1FBRWhDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ25CLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ3RDLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPO2dCQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixRQUFRLEVBQUUsQ0FBQyxDQUFDO2FBQy9DO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsWUFBWSxDQUNSLEtBQVUsRUFDVixJQUFZLEVBQ1osT0FBdUM7UUFFdkMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUUsRUFBRTtZQUN2RCxPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQ1gsbUNBQW1DLE9BQU8sS0FBSyxF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RUFBRTtZQUNqQixPQUFPLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHFCQUFxQixFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUM3RDtJQUNMLENBQUM7Q0FDSixDQUFDO0FBRVcsUUFBQSxPQUFPLEdBQUc7SUFDbkIsT0FBTyxFQUFFLEtBQUs7UUFDVixPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7UUFDN0MsY0FBYyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDcEMsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztDQUNKLENBQUM7QUFFRixTQUFnQixJQUFJLEtBQUksQ0FBQztBQUF6QixvQkFBeUI7QUFDekIsU0FBZ0IsTUFBTSxLQUFJLENBQUM7QUFBM0Isd0JBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIHhsc3ggZnJvbSBcInhsc3hcIjtcblxuaW50ZXJmYWNlIEV4Y2VsQ29udmVydGVyIHtcbiAgICBwYXJzZVZhbHVlKFxuICAgICAgICB2YWx1ZTogYW55LFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNvbnRleHQ6IHsgcm93OiBudW1iZXI7IGZpZWxkOiBzdHJpbmcgfVxuICAgICk6IGFueTtcbiAgICBjb252ZXJ0U2hlZXRUb1R5cGVkSnNvbihzaGVldDogYW55LCBmaWxlbmFtZTogc3RyaW5nKTogYW55W107XG4gICAgY29udmVydEV4Y2VsVG9Kc29uKCk6IHZvaWQ7XG4gICAgY2xlYW5EaXJlY3RvcnkoZGlyOiBzdHJpbmcsIGV4dDogc3RyaW5nKTogdm9pZDtcbiAgICB2YWxpZGF0ZVR5cGUoXG4gICAgICAgIHZhbHVlOiBhbnksXG4gICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgY29udGV4dDogeyByb3c6IG51bWJlcjsgZmllbGQ6IHN0cmluZyB9XG4gICAgKTogdm9pZDtcbn1cblxuY29uc3QgZXhjZWxDb252ZXJ0ZXI6IEV4Y2VsQ29udmVydGVyID0ge1xuICAgIGNsZWFuRGlyZWN0b3J5KGRpcjogc3RyaW5nLCBleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyKTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGUuZW5kc1dpdGgoZXh0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGRpciwgZmlsZSk7XG4gICAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhmaWxlUGF0aCk7IC8vIOWIoOmZpOaWh+S7tlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQ2xlYW5dIERlbGV0ZWQ6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVR5cGUoXG4gICAgICAgIHZhbHVlOiBhbnksXG4gICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgY29udGV4dDogeyByb3c6IG51bWJlcjsgZmllbGQ6IHN0cmluZyB9XG4gICAgKTogdm9pZCB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5lbmRzV2l0aChcIltdXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYXJyYXkgKHN0cmluZykgYnV0IGdvdCAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImludFwiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlmIChpc05hTihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG51bWJlciBidXQgZ290IFwiJHt2YWx1ZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb3dlciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlciAhPT0gXCJ0cnVlXCIgJiYgbG93ZXIgIT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBib29sZWFuICh0cnVlL2ZhbHNlKSBidXQgZ290IFwiJHt2YWx1ZX1cImBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIGJ1dCBnb3QgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgIT09IFwib2JqZWN0XCIgfHwgcGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIEpTT04gb2JqZWN0IGJ1dCBnb3QgJHt0eXBlb2YgcGFyc2VkfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIGZvcm1hdDogXCIke3ZhbHVlfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQWRkIG1vcmUgdHlwZSB2YWxpZGF0aW9ucyBhcyBuZWVkZWRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZVZhbHVlKFxuICAgICAgICB2YWx1ZTogYW55LFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNvbnRleHQ6IHsgcm93OiBudW1iZXI7IGZpZWxkOiBzdHJpbmcgfVxuICAgICk6IGFueSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHR5cGUgZmlyc3RcbiAgICAgICAgdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIHR5cGUsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBhcnJheSB0eXBlc1xuICAgICAgICBpZiAodHlwZS5lbmRzV2l0aChcIltdXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IHR5cGUucmVwbGFjZShcIltdXCIsIFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFZhbHVlID0gdmFsdWUudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAodHJpbW1lZFZhbHVlID09PSBcIltdXCIgfHwgdHJpbW1lZFZhbHVlID09PSBcIlwiKSByZXR1cm4gW107XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIEpTT04gYXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHRyaW1tZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkLm1hcCgoaXRlbSwgaW5kZXgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVmFsdWUoaXRlbSwgZWxlbWVudFR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IGNvbnRleHQucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBgJHtjb250ZXh0LmZpZWxkfVske2luZGV4fV1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVZhbHVlKHBhcnNlZCwgZWxlbWVudFR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogY29udGV4dC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogYCR7Y29udGV4dC5maWVsZH1bMF1gLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRyaW1tZWRWYWx1ZS5zcGxpdChcIixcIikubWFwKChzOiBhbnkpID0+IHMudHJpbSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtOiBhbnksIGluZGV4OiBhbnkpID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VWYWx1ZShpdGVtLCBlbGVtZW50VHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBjb250ZXh0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBgJHtjb250ZXh0LmZpZWxkfVske2luZGV4fV1gLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBIYW5kbGUgYmFzaWMgdHlwZXNcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50XCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb252ZXJ0U2hlZXRUb1R5cGVkSnNvbihzaGVldDogYW55LCBmaWxlbmFtZTogc3RyaW5nKTogYW55W10ge1xuICAgICAgICBjb25zdCBleGNlbERhdGEgPSB4bHN4LnV0aWxzLnNoZWV0X3RvX2pzb24oc2hlZXQsIHsgaGVhZGVyOiAxIH0pO1xuXG4gICAgICAgIGlmIChleGNlbERhdGEubGVuZ3RoIDwgMykgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXhjZWxEYXRhID09PT0gXCIsIGV4Y2VsRGF0YSk7XG5cbiAgICAgICAgY29uc3QgdHlwZURlZnM6IGFueSA9IGV4Y2VsRGF0YVsxXTsgLy8g56ys5LiA6KGM77ya5pWw5o2u57G75Z6LXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXM6IGFueSA9IGV4Y2VsRGF0YVsyXTsgLy8g56ys5LqM6KGM77ya5a2X5q615ZCNXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgLy8g5LuO56ys5LiJ6KGM5byA5aeL6Kej5p6Q5pWw5o2uXG4gICAgICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZXhjZWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb3c6IGFueSA9IGV4Y2VsRGF0YVtpXTtcbiAgICAgICAgICAgIGlmIChyb3dbMF0gPT0gXCIkZW5kJFwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBmaWVsZE5hbWVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGROYW1lKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHR5cGVEZWZzW2pdIHx8IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSByb3dbal07XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbZmllbGROYW1lXSA9IHRoaXMucGFyc2VWYWx1ZShyYXdWYWx1ZSwgZmllbGRUeXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IGkgKyAxLCAvLyBFeGNlbOihjOWPt+S7jjHlvIDlp4tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBgWyR7ZmlsZW5hbWV9XSDooYwgJHtpICsgMX0sIOWIlyBcIiR7ZmllbGROYW1lfVwiOiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBg57G75Z6LOiAke2ZpZWxkVHlwZX0sIOWAvDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYOWPkeeOsCAke2Vycm9ycy5sZW5ndGh9IOS4quexu+Wei+mUmeivrzpcXG4ke2Vycm9ycy5qb2luKFwiXFxuXFxuXCIpfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjb252ZXJ0RXhjZWxUb0pzb24oKTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltFeGNlbENvbnZlcnRlcl0gU3RhcnRpbmcgY29udmVyc2lvblwiKTtcblxuICAgICAgICAgICAgLy8g6I635Y+W6aG555uu5qC555uu5b2V55qE5LiK5LiA57qn55uu5b2VXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0UGFyZW50RGlyID0gcGF0aC5kaXJuYW1lKEVkaXRvci5Qcm9qZWN0LnBhdGgpO1xuICAgICAgICAgICAgLy8g6K6+572uRXhjZWznm67lvZXkuLrkuIrkuIDnuqfnm67lvZXnmoRyZXMvZGF0YVxuICAgICAgICAgICAgY29uc3QgZXhjZWxEaXIgPSBwYXRoLmpvaW4ocHJvamVjdFBhcmVudERpciwgXCJwcm9qZWN0UmVzXCIsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dERpciA9IHBhdGguam9pbihcbiAgICAgICAgICAgICAgICBFZGl0b3IuUHJvamVjdC5wYXRoLFxuICAgICAgICAgICAgICAgIFwiYXNzZXRzXCIsXG4gICAgICAgICAgICAgICAgXCJyZXNvdXJjZXNcIixcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZXhjZWxEaXIpKSB7XG4gICAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKGV4Y2VsRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmluZm8oYENyZWF0ZWQgZXhjZWwgZGlyZWN0b3J5OiAke2V4Y2VsRGlyfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG91dHB1dERpcikpIHtcbiAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMob3V0cHV0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhbkRpcmVjdG9yeShvdXRwdXREaXIsIFwiLmpzb25cIik7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoZXhjZWxEaXIpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShmaWxlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzWGxzeCA9IGV4dCA9PT0gXCIueGxzeFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVGVtcEZpbGUgPVxuICAgICAgICAgICAgICAgICAgICBmaWxlLnN0YXJ0c1dpdGgoXCJ+JFwiKSB8fCBmaWxlLnN0YXJ0c1dpdGgoXCJ+XCIpOyAvLyDljLnphY3kuKTnp43kuLTml7bmlofku7bmoLzlvI9cblxuICAgICAgICAgICAgICAgIC8vIOWPquS/neeVmS54bHN45LiU5LiN5piv5Li05pe25paH5Lu2XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzWGxzeCAmJiAhaXNUZW1wRmlsZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLkRpYWxvZy5pbmZvKFxuICAgICAgICAgICAgICAgICAgICBcIltFeGNlbENvbnZlcnRlcl0gTm8gLnhsc3ggZmlsZXMgZm91bmQgaW46IFwiICsgZXhjZWxEaXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmYWlsZWRGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFsbEVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjZWxQYXRoID0gcGF0aC5qb2luKGV4Y2VsRGlyLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbk5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGUsIFwiLnhsc3hcIikgKyBcIi5qc29uXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25QYXRoID0gcGF0aC5qb2luKG91dHB1dERpciwganNvbk5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtib29rID0geGxzeC5yZWFkRmlsZShleGNlbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGVldE5hbWVzID0gd29ya2Jvb2suU2hlZXROYW1lcztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hlZXROYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHdvcmtzaGVldHMgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5jb252ZXJ0U2hlZXRUb1R5cGVkSnNvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtib29rLlNoZWV0c1tzaGVldE5hbWVzWzBdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhqc29uUGF0aCwgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGBbRXhjZWxDb252ZXJ0ZXJdIFN1Y2Nlc3M6ICR7ZmlsZX0gLT4gJHtqc29uTmFtZX1gXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWRGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBhbGxFcnJvcnMucHVzaChgJHtmaWxlfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbRXhjZWxDb252ZXJ0ZXJdIEZhaWxlZDogJHtmaWxlfWAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXBvcnQgPSBgW0V4Y2VsQ29udmVydGVyXSDovazmjaLlrozmiJAhXFxuXFxu5oiQ5YqfOiAke3N1Y2Nlc3NDb3VudH1cXG7lpLHotKU6ICR7ZmFpbGVkRmlsZXMubGVuZ3RofWA7XG4gICAgICAgICAgICBpZiAoYWxsRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXBvcnQgKz0gYFxcblxcbumUmeivr+ivpuaDhTpcXG4ke2FsbEVycm9ycy5qb2luKFwiXFxuXFxuXCIpfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmYWlsZWRGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLkRpYWxvZy5lcnJvcihcIltFeGNlbENvbnZlcnRlcl0g6L2s5o2i5Ye66ZSZXCIgKyByZXBvcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmluZm8oXCJbRXhjZWxDb252ZXJ0ZXJdIOi9rOaNouWujOaIkFwiICsgcmVwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltFeGNlbENvbnZlcnRlcl0gR2xvYmFsIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBFZGl0b3IuRGlhbG9nLmVycm9yKFwiW0V4Y2VsQ29udmVydGVyXSDplJnor69cIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgZXhlY3V0ZTogYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltFeGNlbENvbnZlcnRlcl0gRXhlY3V0aW5nLi4uXCIpO1xuICAgICAgICBleGNlbENvbnZlcnRlci5jb252ZXJ0RXhjZWxUb0pzb24oKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkKCkge31cbmV4cG9ydCBmdW5jdGlvbiB1bmxvYWQoKSB7fVxuIl19